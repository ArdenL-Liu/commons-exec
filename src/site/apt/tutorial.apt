~~ 
~~ Licensed to the Apache Software Foundation (ASF) under one or more
~~  contributor license agreements.  See the NOTICE file distributed with
~~  this work for additional information regarding copyright ownership.
~~  The ASF licenses this file to You under the Apache License, Version 2.0
~~  (the "License"); you may not use this file except in compliance with
~~  the License.  You may obtain a copy of the License at
~~
~~      http://www.apache.org/licenses/LICENSE-2.0
~~
~~  Unless required by applicable law or agreed to in writing, software
~~  distributed under the License is distributed on an "AS IS" BASIS,
~~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~  See the License for the specific language governing permissions and
~~  limitations under the License.
~~
~~

 --------
Apache Commons Exec Tutorial
 --------
 --------
12 November 2008
 --------

Apache Commons Exec

* The First Encounter

  At this point we can safely assume that you would like to start some subprocesses from within your
  Java application and you spent some time here to do it properly. You look at Commons Exec and think
  "Wow - calling Runtime.exec() is easy and the Apache folks are wasting their and my time
  with tons of code".
  
  Well, we learned it the hard way (in my case more than once) that using plain Runtime.exec() can be 
  a painful experience. Therefore you are invited to delve into commons-exec and have a look at the
  hard lessons the easy way ...
  
* Taming Your First Process

  Let's look at a real example - we would like to print PDF documents from within your Java
  application. After googling a while it turns out to be a minor headache and using Adobe Acrobat
  seems to be a good option.

  The command line under Windows should look like "AcroRd32.exe /p /h file" assuming that the
  Acrobat Reader is found in the path.

+----------------------------------------------------------------------------
String line = "AcroRd32.exe /p /h " + file.getAbsolutePath();
CommandLine commandLine = CommandLine.parse(line);
DefaultExecutor executor = new DefaultExecutor();
int exitValue = executor.execute(commandLine);
+----------------------------------------------------------------------------

  You successfuly printed your first PDF document but at the end an exception is thrown - what
  happpend? Mhhmm, Acrobat Reader returned an exit value of '1' on success which is usually
  considered as an execution failure. So we have to tweak our code to fix this odd behaviour

+----------------------------------------------------------------------------
String line = "AcroRd32.exe /p /h " + file.getAbsolutePath();
CommandLine commandLine = CommandLine.parse(line);
DefaultExecutor executor = new DefaultExecutor();
executor.setExitValue(1);
int exitValue = executor.execute(commandLine);
+----------------------------------------------------------------------------

* To Watchdog Or Not To Watchdog

  You happily printed for a while but now your application blocks - your printing subprocess
  hangs for some obvious or not so obvious reason. Starting is easy but what to do with a run-away
  Acrobat Reader?! Luckily commons-exec provides a watchdog which does the work for you.
  Here is the improved code which kills a run-away process after sixty seconds.

+----------------------------------------------------------------------------
String line = "AcroRd32.exe /p /h " + file.getAbsolutePath();
CommandLine commandLine = CommandLine.parse(line);
DefaultExecutor executor = new DefaultExecutor();
executor.setExitValue(1);
ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);
executor.setWatchdog(watchdog);
int exitValue = executor.execute(commandLine);
+----------------------------------------------------------------------------

* Quoting Is Your Friend

  Well, the code worked for quite a while until a new customer complained that
  no documents are printed. It took half a day to find out that the following file
  'C:\\Document And Settings\\documents\\432432.pdf' could not be printed. Due to the
  spaces and without further quoting the command line fell literally apart into
  the following snippet

+----------------------------------------------------------------------------
> AcroRd32.exe /p /h C:\Document And Settings\documents\432432.pdf
+----------------------------------------------------------------------------

  As a quick fix we added double quotes which tells commons-exec to handle
  the file as a single command line argument instead of splitting it into
  parts.
  
+----------------------------------------------------------------------------
String line = "AcroRd32.exe /p /h \"" + file.getAbsolutePath() + "\"";
CommandLine commandLine = CommandLine.parse(line);
DefaultExecutor executor = new DefaultExecutor();
executor.setExitValue(1);
ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);
executor.setWatchdog(watchdog);
int exitValue = executor.execute(commandLine);
+----------------------------------------------------------------------------

* Build the Command Line Incrementally

  The previous problem stems from the fact that commons-exec tried to split
  a single command line string into a string array considering single and
  double quotes. At the end of the day this is error-prone so we recommend
  building the command line incrementally - according to the same reasoning
  the Ant documentation does not recommend passing a single command line to
  the <exec> target (see deprecated command attribute for 
  {{{http://ant.apache.org/manual/CoreTasks/exec.html}exec}} task)
  
+----------------------------------------------------------------------------
CommandLine commandLine = CommandLine.parse("AcroRd32.exe");
commandLine.addArgument("/p");
commandLine.addArgument("/h");
commandLine.addArgument(file.getAbsolutePath());
DefaultExecutor executor = new DefaultExecutor();
executor.setExitValue(1);
ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);
executor.setWatchdog(watchdog);
int exitValue = executor.execute(commandLine);
+----------------------------------------------------------------------------

* Using Command Line Expansion

  In the previous example we basically hardcoded the command line to be
  executed. Using a different application to print PDF documents or just
  tinkering with command line options would require a new release - uncool.
  To write better code you can look at the following code snippet (and
  don't forget that using a command line string is dangerous)

+----------------------------------------------------------------------------
CommandLine commandLine;
HashMap map = new HashMap();
map.put("file", "C:\Document And Settings\documents\432432.pdf");
commandLine  = CommandLine.parse("AcroRd32.exe /p /h \"${file}\"", map);

// Or you can use expansion with individual parameters:

CommandLine commandLine = CommandLine.parse("AcroRd32.exe");
commandLine.addArgument("/p");
commandLine.addArgument("/h");
commandLine.addArgument("${file}");
HashMap map = new HashMap();
map.put("file", "C:\Document And Settings\documents\432432.pdf");
commandLine.setSubstitutionMap(map);
+----------------------------------------------------------------------------

* Unblock Your Execution

  Up to now we have a working example but it would not be good enough for
  production - because it is blocking.

  At the one hand your print process might block when it tries to write to
  'stdout' or 'stderr'. Avoiding this problem is done by setting a pump stream
  handler which pumps the output from the print process to your own process.

  On the other hand your own worker thread will block until the print process
  has exited. Therefore executing the print job asynchronously will do the trick.
  In this example we create an instance of 'ExecuteResultHandler' and pass it
  to the 'Executor' instance in order to execute the process asynchronously.
  The 'resultHandler' picks up any offending exception or the process exit
  code.

+----------------------------------------------------------------------------
CommandLine commandLine = CommandLine.parse(this.acroRd32Script.getAbsolutePath());
commandLine.addArgument("/p");
commandLine.addArgument("/h");
commandLine.addArgument("${file}");
HashMap map = new HashMap();
map.put("file", "./pom.xml");
commandLine.setSubstitutionMap(map);

DefaultExecuteResultHandler resultHandler = new DefaultExecuteResultHandler();

ExecuteWatchdog watchdog = new ExecuteWatchdog(timeout1);

Executor executor = new DefaultExecutor();
executor.setExitValue(1);
executor.setStreamHandler(new PumpStreamHandler());
executor.setWatchdog(watchdog);
executor.execute(commandLine, resultHandler);
+----------------------------------------------------------------------------
  
